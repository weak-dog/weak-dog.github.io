[{"content":"Xunpack: Cross-Architecture Unpacking for Linux IoT Malware 问题背景 IoT malware的特点在于架构的多样性，而现有的恶意程序检测工具大多只能处理x86程序，无法处理Arm和MIPS等架构的程序，并且难以对抗packer和anti-analysis技术。\nXunpack的设计原则 使用QEMU使恶意代码分析与特定架构脱钩，只要QEMU支持，Xunpack就能解压任何架构的恶意软件。\n贡献点 设计并实现了首个针对IoT malware的跨架构unpacker。 引入了SelectiveDump，这是一种对分散在memory dump中的恶意软件原始代码进行重建的技术。 使用真实世界的ELF packer进行实验，证明Xunpack的抗分析能力。 Xunpack的两个阶段 Online analysis for dump generation\n使用QEMU的system-level emulation和tiny code generator(TCG)插件接口开发了dump generation module。用于使用独立于体系结构的方式捕获两类事件：自修改代码的执行和从内核到用户区目标代码的转换。\nOffline analysis for original code reconstruction from those dumps\n论文引入了SelectiveDump技术，通过在memory dump中为原始代码的特定部分寻找候选内存区域并选择最合适的区域重建原始代码。SelectiveDump将内存区域划分成多个分块，计算和比较每个内存区域的熵值并进行选择，从而对抗VI型packer（VI型packer在执行的任何时刻都只会unpack出原始代码的一小部分，不存在某个时刻能unpack出完整的原始代码）。\nXunpack的挑战 识别恶意代码的执行。Xunpack建立在QEMU的系统仿真上，需要将运行的malware与其他进程分开，而不依赖于特定的体系结构和平台。现有研究大多根据进程线程标识符（PID，TID）或特殊用途寄存器（CR3或ASID）进行识别，这些方法都依赖于底层架构。 捕获目标代码中的特定事件，例如从系统调用返回，而无需依赖于特定架构指令的执行，如sysret。 内存转储，即使从虚拟内存地址到物理地址的转换并不总是可能的。一些CPU，例如MIPS架构，不支持用于内存地址转换的page-table-walk，因此我们始终无法解析我们需要转储的虚拟地址范围。 VI型packer，目前还没有针对这类packer的unpack方法。 论文实验： unpack使用elfpack打包的14种不同架构的二进制文件，展示Xunpack的跨架构能力。 unpack使用11种真实Linux ELF packer打包的二进制文件，并与现有unpacker进行比较。 BACKGROUND 1. Malware Unpacking unpacking是静态分析或逆向分析之前的必然步骤。最原始的unpacking方法使用调试器手动脱壳。自动化unpacker大多使用write-and-then execution技术，将程序在运行过程中动态写入的内存区域标记为dirty memory，当dirty memory被执行时生成memory dump。然而当执行一个packed malware，write-and-then execution可能会产生许多memory dump，只有其中一部分包含程序的原始代码，需要通过某种方法识别包含原始代码的dump。主要有以下几种方法：\n最原始的方法选择等待一定时间后生成dump，基于原始代码很可能在恶意软件执行后期出现的假设。 反病毒扫描。根据恶意代码签名的模式匹配结果来确定带有原始代码的dump。由于恶意签名可能与原始代码匹配，而不与packer代码匹配，因此可以通过是有命中签名判断unpacking过程在哪一点完成。 熵。加壳程序的熵值较高，因此熵值较低的dump更可能包含原始代码。 code-to-data ratio（C2DR）。C2DR高的dump更可能包含原始代码。 2. Packer Taxonomy 论文SoK: Deep Packer Inspection将packer分为6类：\nType Ⅰ：由single unpacking layer组成，执行unpacking routine后跳转到原始代码。 Type Ⅱ：包含多个unpacking layer，顺序执行各层。 Type Ⅲ：包含多个unpacking layer，循环执行各层，在各层之间来回切换，形成更复杂的拓扑结构，如循环。 Type Ⅳ：由单层或多层unpacking layer构成，其中有些layer不仅负责unpack，还负责hook和插桩。交错执行unpacking layer和原始代码。 Type Ⅴ：类似Type Ⅳ，但包含原始代码的unpacking layer有多个帧，当执行到某个帧的时候这个帧才被unpack。因此memory dump中只包含在分期期间执行的原始代码。 Type Ⅵ：类似Type Ⅴ，但在执行完原始代码后会重新打包执行过的原始代码。因此memory dump中只包含在dump时刻刚刚执行过的原始代码。这种技术称为shift frame decoding。 MOTIVATION 1. Lack of tools for diverse architectures 针对非x86 malware的unpacking技术很少，而IoT malware大多是非x86架构（88%）。\n2. Lack of resistance against anti-analysis Malformed ELF Header\nProcess-level emulation通常会从可执行文件header中收集仿真需要的信息，但malware作者经常修改这些字段，如UPX会修改ELF头中的数据。\nDual-mapping\n这种技术通过将一个物理内存区域映射到两个不同的虚拟地址区域，扰乱了write-and-then-execute的unpack过程。malware使用一个地址来写入unpacked code，使用另一个地址来执行这段代码，使得写入和执行的虚拟内存地址不同。ELFCrypt使用了类似技术，首先通过memfd_create创建一个文件描述符，用于将unpacked代码写入内存，然后使用fexecve执行unpacked代码。由于通过文件描述符写入的缓冲区地址不会暴露，因此写入后执行方法无法识别写入代码的内存地址。\nShift frame decoding\nKiteshield使用这种技术，在每个函数的入口和出口都设置了hook，并使用ptrace捕获它们的执行过程，以便解码和重新编码。\nInvocation of unsupported system calls\n通过调用handler缺失或没有正确实现的特定系统调用来干扰仿真分析。为malware分析准备足够的进程级仿真系统调用handler是一项挑战。例如截至6.0.50版，QEMU的进程级仿真不支持ptrace和execveat系统调用。即使仿真器实现了所需的素有handler，它们也可能导致malware通过观察仿真器与真实环境的行为差异来检测仿真器。\n研究范围 排除了使用Perl和Python等脚本语言编写的恶意软件，专注于编译后的ELF格式可执行文件，它们构成了IoT malware的主体（94.3%）。 排除使用进程级虚拟化的打包程序。 排除死代码。 模型架构 Dump Generation 1. Target Code Identification 使用code tainting技术根据自修改代码的执行情况确定分析目标。首先解析ELF header，识别text段所在的内存地址区域，然后对区域内指令的内存写入操作做system-widely monitor，同时使用shadow memory（一种存储这些标签的数据结构）对写入区域进行标记，shadow memory将每个物理内存地址映射为一个标记。如果写入的内存区域被执行，会将其确定为分析目标。通过将内存写入指令的标签传播的内存区域就能准确跟踪目标代码的执行情况。这种设计可以解决Dual-mapping问题：由于在物理地址层监控内存的写入和执行，因此即使目标代码使用不同的虚拟地址写入和操作同一个物理内存区域，Xunpack也能准确识别目标代码的执行。\n2. Dump Generation Trigge 为了确定原始代码被写入内存的时机，论文设计了两种触发事件：\nlayer Transitions\n论文定义在unpack过程中每次迭代得到的unpacked code为一个layer。例如某段代码将数据写入一个特定的内存区域，这个区域就是一个layer。当Xunpack捕捉到layer之间的转换时，就会对写入的memory page生成一个dump。\nTransitions to Target Code\n将从内核空间到用户空间中的目标代码执行流转换作为生成dump的触发器。这些转换可能由系统调用返回、异常或中断处理、上下文切换引起。为了捕获这种转换，需要确定内核空间和用户空间的边界，而边界的位置与架构有关。为了解决这个问题，Xunpack在引导内核镜像（ELF格式的可执行文件）之前从内核镜像中提取内核在虚拟内存地址空间中的位置。具体来说，可以从section和program header中获取其位置。如果内核镜像被压缩，则使用vmlinux-to-elf从中提取原始内核。\nXunpack使用tiny code generation（TCG）插件接口（I/F）实现dump generation组件。TCG是QEMU内部使用的IR，支持多种架构。子操作系统的指令被翻译成TCG，然后再翻译成主机操作系统的指令，从而模拟子系统指令的行为。\nCode Reconstruction 这一阶段重建ELF文件，使其尽可能接近原始代码。\n1. Dump Selection 从dump文件中选择更接近原始代码的region或chunk。由于packed程序在执行时可能会多次覆盖某个内存区域，产生多个layer，从而得到多个dump文件。其中部分dump文件包含原始代码，现有方法通过计算每个dump文件的熵来选择。但是基于熵的方法往往无法完全恢复使用Type Ⅴ或Type Ⅵ packer加壳的程序，因为region边界与实际unpacking framge不一致（dump区域同时包含unpacked code和packed code）。Xunpack使用了更细粒度的划分方法SelectiveDump：将一个region划分为适当大小的块，计算每个块的熵，选择熵值较小的region作为结果。\n2. ELF Reconstruction 重建流程分为三步\nminimum ELF creation\n创建一个最小的ELF可执行文件，包括header, NULL section, shstrtab section以及section header table等。\nchunk insertion\n将每个chunk或region插入到ELF可执行文件中相应的偏移位置。\nsymbol table reconstruction\n与windows脱壳中重建IAT类似，区别在于Linux malware通常使用静态链接库，并丢失其符号信息，而windows malware通常使用动态链接库，更有可能保留导入函数名。识别静态链接库的函数名难度较大，这一步是可选的。具体而言Xunpack使用IDA FLIRT或签名匹配等外部工具恢复这些函数的符号信息。\n","permalink":"https://weak-dog.github.io/en/posts/tech/xunpack/","summary":"Xunpack: Cross-Architecture Unpacking for Linux IoT Malware 问题背","title":"Xunpack"},{"content":"Intel pin 二进制动态插桩简介 插桩可以在不同阶段执行，例如在源代码中、编译时、链接时以及运行时。插桩方式可以分为两类：\n源插桩（source instrumentation）。源插桩要求掌握应用程序的源代码，否则无法进行插桩。这一条件在实际应用中较难实现。因为在生产环境中，源码一般不予公开。 二进制插桩（binary instrumentation）。不需要源代码，直接对二进制程序插桩。 二进制插桩又可分为两类，静态二进制插桩（static instrumentation）和动态二进制插桩(dynamic binary instrumentation)\n静态插桩。在程序运行前对目标程序进行重写后再运行。静态插桩会修改源文件，因此必须提前对各项源文件进行备份，且每次插桩时都需要进行备份、修改代码、重编译过程，操作费事且复杂。\n动态插桩。在程序运行时进行动态编译、插桩，使用的是源代码进行动态插桩后的新代码，源文件不受影响。在jit模式下，执行的都是pin生成的代码，原始代码一般用作参考，并不实际执行。\n常见的动态插桩工具有：Pin、DynamoRIO、Valgrind、Nirvana、Frida等。\nIntel Pin简介 Pin是一种插桩工具，支持Linux和Windows系统以及IA-32、Intel(R)64和Intel(R)架构的可执行文件。pin 允许在可执行文件 (executable) 文件的任意位置插入任意的代码 (C/C++ 编写) ，它的代码可以被动态的添加到正在执行的可执行文件中，另外还可以将 pin 附加到正在运行的进程中。\npin 提供了丰富的 API，可以抽象出底层指令集特性，并允许将诸如寄存器内容之类的上下文 (context) 信息作为参数传递给注入的代码，pin 会自动保存和恢复被注入代码覆盖的寄存器，以便让应用程序继续工作，pin还支持访问有限的符号和调试信息。\n插桩包含以下两个重要部分，这两个部分通过pintool实现，pintool可以理解为pin中的插件。\n决定代码插入位置和内容的机制 在插入点执行什么代码 可以将pin看作一个简单的just-in-time编译器，输入的是可执行文件，输出的是插桩完毕的程序。pin截获第一条可执行指令，产生新的代码序列，并将控制流程转移到新生成的代码序列。新产生的序列基本上与原序列一致，但是pin可以保证在一个分支结束后重新获取控制权，获得控制权之后pin可以为分支目标产生代码并执行。pin可以通过将所有产生的代码放置在内存中以便于重新使用这些代码，加快从一个分支跳转到另一个分支之间的过程，提高效率。\nPin插桩粒度 指令插桩（instruction instrumentation）：INS_AddInstrumentFunction\nPin提供INS对象表示目标程序中的一条指令，可以通过INS获取指令的地址、操作码、操作数等信息。\n路径插桩（trace instrumentation）：TRACE_AddInstrumentFunction\ntrace是一系列顺序执行的指令组成的序列（一条执行路径），通常从程序的入口点开始，只到某个条件触发了分支或程序结束：\n无条件的控制转移：call、ret（trace可以包含jcc指令，因此trace中的代码可能会有多条执行路径，多个基本块） 设定的条件控制转移数 设定的trace的指令数 函数插桩（routine instrumentation）：RTN_AddInstrumentFunction\nroutine表示程序中的函数或子例程，是一组指令的集合，通常包含在一个函数体内。Pin中使用RTN对象表示程序中的函数，可用于分析函数调用、返回等操作。\n映像插桩（Image instrumentation）：IMG_AddInstrumentFunction\nimage指程序在内存中的可执行映像或库文件。Pin中使用IMG对象表示加载到内存中的可执行映像或库文件。\nimage instrumentation需要通过符号信息划定routine边界，因此必须在PIN_Init之前调用PIN_InitSybmols。\nPin插桩多线程程序 Pin提供锁机制（PIN_LOCK）和线程管理（PIN_Yield）API，能够对多线程程序进行插桩。Pin在每个线程开始和结束时提供回调（PIN_AddThreadStartFunction和PIN_AddThreadFiniFunction）。Pin提供一个分析例程参数IARG_THREAD_ID，用于传递线程ID，这个ID由PIN生成的，与O/S系统线程ID不同，是一个从0开始的很小的数字，可用作线程数据数组的索引或Pin用户锁的值。\ncontext概念 我们最开始介绍过了，pin 在插桩前后要能够保存和恢复可执行文件的上下文 (context) 信息，这样才能够保证 pin 不会影响到原目标插桩程序的正常执行，我们可以在调用 INS_InsertCall 函数时，将这个 context 作为一个参数传递给具体插桩函数 (IARG_CONTEXT)，通过这个 context 我们可以读取/修改架构级别(逻辑)寄存器的具体值，包括整型寄存器、浮点 status/control 寄存器，fp 栈寄存器等等，这些函数的具体用法不过多的解释，注意在插桩函数中对这些寄存器的修改返回后都被忽略，如果想真正实现能在修改后的 context 运行，要执行下面的 PIN_ExcuteAt 函数，另外这些寄存器都是架构级别的，无法访问到物理寄存器级别。\nPin官方实例 计算指令数据（指令级插桩）\n目标程序每执行一条指令前会先调用注册的插桩函数Instruction，这个函数会在每次执行指令前调用docount函数，令全局变量icount自增1，然后执行原始指令，重复进行该过程，直到程序执行结束，将统计结果写入指定的输出文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026#34;pin.H\u0026#34; using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; //声明一个全局变量统计指令条数 static UINT64 icount = 0; //每次Instrction函数都会调用这个函数使icount+1 VOID docount() { icount++; } //每执行一条instruction前都会执行Instruction函数 VOID Instruction(INS ins, VOID* v) { //ins为当前程序准备执行的指令 //IPOINT_BEFORE指定在指令执行前执行函数 //docount为注册的函数 //IARG_END指明传入docount的参数的结尾，这里docount传入参数为空 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); } KNOB\u0026lt; string \u0026gt; KnobOutputFile(KNOB_MODE_WRITEONCE, \u0026#34;pintool\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;inscount.out\u0026#34;, \u0026#34;specify output file name\u0026#34;); // 最后结束时执行这个函数，将指令条数统计结果写入输出文件中 VOID Fini(INT32 code, VOID* v) { OutFile.setf(ios::showbase); OutFile \u0026lt;\u0026lt; \u0026#34;Count \u0026#34; \u0026lt;\u0026lt; icount \u0026lt;\u0026lt; endl; OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u0026lt;\u0026lt; \u0026#34;This tool counts the number of dynamic instructions executed\u0026#34; \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; KNOB_BASE::StringKnobSummary() \u0026lt;\u0026lt; endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ /* argc, argv are the entire command line: pin -t \u0026lt;toolname\u0026gt; -- ... */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化 pin if (PIN_Init(argc, argv)) return Usage(); //打开输出文件 OutFile.open(KnobOutputFile.Value().c_str()); // 注册Instruction函数，每次执行指令前调用 INS_AddInstrumentFunction(Instruction, 0); //注册终止函数 PIN_AddFiniFunction(Fini, 0); //开始执行程序 PIN_StartProgram(); return 0; } ","permalink":"https://weak-dog.github.io/en/posts/tech/pin1/","summary":"Intel pin 二进制动态插桩简","title":"Pin1"},{"content":"jTrans：Jump-Aware Transformer for Binary Code Similarity Detection 论文提出了一种新的学习二进制代码representation的方法jTrans：设计了一种新的jump-aware representation以及相应的预训练任务。同时构造了一个新的二进制程序数据集BinaryCorp。\n传统的二进制相似性检测（BCSD）方法大多基于CFG，这种方法时间开销大且鲁棒性差，因为编译器优化等因素会改变程序CFG，改进方法通过计算CFG片段的相似性提高鲁棒性，但基于人工构造的特征，导致这些方法不能精确提取程序语义。\nSOTA方法大多基于机器学习技术，将目标二进制程序转化成特征向量，在向量空间中计算相似性。Asm2Vec和SAFE等基于NLP方法；另一些方法基于GNN学习CFG的representation；还有一些方法结合使用上述两种方法：使用NLP技术计算基本块的representation，根据CFG构造GNN进一步处理基本块representation。\nSOTA方法存在的缺点：\nNPL-based方法只考虑了指令的序列顺序以及指令之间的关系，而忽略了程序的实际执行信息（如控制流），缺乏对程序的语义理解，无法应对编译优化产生的影响。 仅依靠CFG会遗漏每个基本块的语义，Genius和Gemini使用人工提取的特征（指令数）扩展CFG，但这些特征不足以捕获代码语义。另外，这些方案使用GNN理解CFG，GNN只能捕获结构信息，而且训练和并行相对困难。 用于训练和评估现有方案的数据集的体量和多样性不够大，缺乏一个通用的大型数据集。SOTA各自使用各自构建的数据集，存在过拟合的可能，造成性能高的假象。 jump-aware representation即通过共享指令的每个跳转目标的token embedding和position embedding参数来捕获控制流信息。首先使用无监督学习任务对jTrans进行预训练，学习指令语义和控制流信息，之后对jTrans进行微调，匹配语义相似的函数。不依赖于GNN遍历相应的CFG。\nPreprocessing Instructions 使用助记符和操作数作为tokens 使用\u0026lt;str\u0026gt;代表字符串 使用\u0026lt;const\u0026gt;代表立即数 将外部函数调用的名称和标签作为tokens，将内部函数调用的名称替换为\u0026lt;function\u0026gt; 对于每个跳转对，使用JUMP_XXX替换源token，XXX是该跳转对的目标token顺序，消除随机基址的影响。 Modeling Jump Instructions 修改了位置编码机制，以反映跳转指令的影响。位置编码的隐含逻辑是标记之间的距离越大，表示相互影响越弱，而跳转指令能够将代码中相聚较远的区域结合起来。方法是通过参数共享实现：对于每个跳转对，source token\u0026rsquo;s embedding被用作target token的positional encoding。jTrans目前只考虑了直接跳转。\nTrain Pre-train jTrans\nMLM\njump task prediction(JTP)：给定一个随机选择的jump source token，标记为\u0026lt;LOC\u0026gt;，预测相应的target token。\nFine-Tuning\n针对函数相似性检查这一监督学习任务对模型进行微调。\n","permalink":"https://weak-dog.github.io/en/posts/tech/jtrans/","summary":"jTrans：Jum","title":"JTrans"},{"content":"1. 安装hugo mac用户推荐使用HomeBrew工具安装，执行命令brew install hugo进行安装。\n执行hugo version检查是否安装成功，若出现版本信息则安装成功。\n2. 新建站点 终端进入想要存放网站文件夹的地址，执行hugo new site yoursite，就会在当前文件夹内出现网站目录结构。其中的配置文件为toml格式，如果想要yml格式的配置文件可以执行hugo new site yoursite -f yml。\n网站目录如下\n1 2 3 4 5 6 7 8 9 +------------ │ config.toml ├─archetypes │ default.md ├─content # ├─data ├─layouts ├─static └─themes 3. 更换主题 在hugo官网hugo主题官网上寻找好看的主题，点击会跳转到主题对应的github仓库，将主题下载并放在网站目录的themes文件夹下，在配置文件中添加theme: \u0026quot;yourtheme\u0026quot;属性指定主题名称。\n我选择的是PaperMod主题，config.yml参照了Sulv的网站内容编写（复制）。\nConfig.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 baseURL: https://weak-dog.github.io languageCode: zh-cn # en-us title: \u0026#34;Weakdog\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; # 主题名字，和themes文件夹下的一致 enableInlineShortcodes: true #允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启 buildDrafts: false buildFuture: false buildExpired: false #googleAnalytics: UA-123-45 # 谷歌统计 paginate: 15 # 每页显示的文章数 summaryLength: 20 # 文章概览的自字数，默认70 minify: disableXML: true # minifyOutput: true permalinks: #浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: en # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; # contentDir: content/english weight: 1 profileMode: enabled: true title: (〃\u0026#39;▽\u0026#39;〃) subtitle: \u0026#34;👏🏼欢迎光临维克道格的博客\u0026#34; imageUrl: \u0026#34;img/test.jpeg\u0026#34; #图片放在static/img/Q.gif imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life menu: main: - identifier: home name: 🏠主页 url: / weight: 1 - identifier: posts name: 📚文章 url: posts weight: 2 - identifier: archives name: ⏱时间轴 url: archives/ weight: 3 - identifier: tags name: 🔖标签 url: tags weight: 4 - identifier: about name: 🙋🏻‍♂️关于 url: about weight: 5 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. # description: \u0026#34;这是一个纯粹的博客......\u0026#34; author: weakdog # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors defaultTheme: auto # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 comments: true socialIcons: - name: github url: \u0026#34;https://github.com/weak-dog\u0026#34; - name: email url: \u0026#34;mailto:2562258990@qq.com\u0026#34; # editPost: # URL: \u0026#34;https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content\u0026#34; # Text: \u0026#34;Suggest Changes\u0026#34; # edit text # appendFilePath: true # to append file path to Edit link label: #左上角图标 text: \u0026#34;Weakdog\u0026#39;s Blog\u0026#34; icon: \u0026#34;img/test.jpeg\u0026#34; iconHeight: 35 # analytics: #谷歌分析 # google: # SiteVerificationTag: \u0026#34;XYZabc\u0026#34; assets: favicon: \u0026#34;img/test.jpeg\u0026#34; favicon16x16: \u0026#34;img/test.jpeg\u0026#34; favicon32x32: \u0026#34;img/test.jpeg\u0026#34; apple_touch_icon: \u0026#34;test.jpeg\u0026#34; safari_pinned_tab: \u0026#34;test.jpeg\u0026#34; cover: hidden: false # hide everywhere but not in structured data hiddenInList: false # hide on list pages and home hiddenInSingle: false # hide on single page fuseOpts: #搜索配置 isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] twikoo: version: 1.4.11 taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话 highlight: # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true # noClasses: false # style: monokai style: darcula # codeFences：代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。 # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。 # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。 # lineNoStart：行号从编号几开始，一般从 1 开始。 # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true. # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true. # noClasses：使用 class 标签，而不是内嵌的内联样式 privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true 编辑archetypes文件夹下的default.md来修改文章模板，没有的话就创建一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题 date: {{ .Date }} #创建时间 lastmod: {{ .Date }} #更新时间 author: [\u0026#34;weakdog\u0026#34;] #作者 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; #描述 weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 4. 目录设置 按照需求在content文件夹下新建一些目录文件夹，用来存储不同类别的文章。在每个文件夹内添加一个_index.md文件，用来设置目录的标题和展示样式。\n例如posts下的_index.md：\n1 2 3 4 --- title: \u0026#34;📚文章\u0026#34; hidemeta: true # --- posts/tech下的_index.md：\n1 2 3 4 --- title: \u0026#34;👨🏻‍💻技术\u0026#34; hidemeta: true --- 5. 启动网站 终端进入网站目录，执行hugo server -D就可以在本地启动网站，预览地址为localhost:1313。\n执行hugo生成文件夹public，里面包含生成的静态网页文件，这个文件夹可以部署到云服务器或者托管到github上。\n推荐使用hugo -F --cleanDestinationDir命令生成静态网页，因为hugo命令只会往public文件夹里添加新内容，而不会删除冗余内容，而-F命令则会覆盖原来的public文件夹而生成一个全新的public。\n6. 写文章 所有的文章被放在content目录下。如果没有定义别的分类目录的话执行hugo new article.md即可在content目录下生成article.md文件。如果自定义了分类目录，比如我想要在content/posts/tech文件夹里新建文章，则执行hugo new posts/tech/article.md命令，这样文章就会生成到指定目录。\n如果需要在文章里插入图片，则需要在文章所属的文件夹内创建一个与文章同名的文件夹，将需要插入的picture.png图片放进去，在md文件里使用![](picture.png)命令调用。\n7. 将网站部署在github page上 在github上创建yourname.github.io公共仓库，将public文件夹里的内容push上去。在settings里按照如图配置即可。\n输入yourname.github.io即可访问网站。\n8. 一些关键命令 本地预览博客：hugo server -D\n写文章：hugo new posts/tech/文章名称.md\n图片路径：![](pic.png)\n发布博客：hugo -F --cleanDestinationDir\n","permalink":"https://weak-dog.github.io/en/posts/tech/%E5%BB%BA%E7%AB%99/","summary":"1. 安装hugo mac","title":"hugo建站"},{"content":"关于我\n英文名: ??? 职业: ??? 运动: ??? ","permalink":"https://weak-dog.github.io/en/about/","summary":"关于我 英文名: ??? 职业","title":"🙋🏻‍♂️关于"}]