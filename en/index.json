[{"content":"Intel pin 二进制动态插桩简介 插桩可以在不同阶段执行，例如在源代码中、编译时、链接时以及运行时。插桩方式可以分为两类：\n源插桩（source instrumentation）。源插桩要求掌握应用程序的源代码，否则无法进行插桩。这一条件在实际应用中较难实现。因为在生产环境中，源码一般不予公开。 二进制插桩（binary instrumentation）。不需要源代码，直接对二进制程序插桩。 二进制插桩又可分为两类，静态二进制插桩（static instrumentation）和动态二进制插桩(dynamic binary instrumentation)\n静态插桩。在程序运行前对目标程序进行重写后再运行。静态插桩会修改源文件，因此必须提前对各项源文件进行备份，且每次插桩时都需要进行备份、修改代码、重编译过程，操作费事且复杂。\n动态插桩。在程序运行时进行动态编译、插桩，使用的是源代码进行动态插桩后的新代码，源文件不受影响。在jit模式下，执行的都是pin生成的代码，原始代码一般用作参考，并不实际执行。\n常见的动态插桩工具有：Pin、DynamoRIO、Valgrind、Nirvana、Frida等。\nIntel Pin简介 Pin是一种插桩工具，支持Linux和Windows系统以及IA-32、Intel(R)64和Intel(R)架构的可执行文件。pin 允许在可执行文件 (executable) 文件的任意位置插入任意的代码 (C/C++ 编写) ，它的代码可以被动态的添加到正在执行的可执行文件中，另外还可以将 pin 附加到正在运行的进程中。\npin 提供了丰富的 API，可以抽象出底层指令集特性，并允许将诸如寄存器内容之类的上下文 (context) 信息作为参数传递给注入的代码，pin 会自动保存和恢复被注入代码覆盖的寄存器，以便让应用程序继续工作，pin还支持访问有限的符号和调试信息。\n插桩包含以下两个重要部分，这两个部分通过pintool实现，pintool可以理解为pin中的插件。\n决定代码插入位置和内容的机制 在插入点执行什么代码 可以将pin看作一个简单的just-in-time编译器，输入的是可执行文件，输出的是插桩完毕的程序。pin截获第一条可执行指令，产生新的代码序列，并将控制流程转移到新生成的代码序列。新产生的序列基本上与原序列一致，但是pin可以保证在一个分支结束后重新获取控制权，获得控制权之后pin可以为分支目标产生代码并执行。pin可以通过将所有产生的代码放置在内存中以便于重新使用这些代码，加快从一个分支跳转到另一个分支之间的过程，提高效率。\nPin插桩粒度 指令插桩（instruction instrumentation）：INS_AddInstrumentFunction\nPin提供INS对象表示目标程序中的一条指令，可以通过INS获取指令的地址、操作码、操作数等信息。\n路径插桩（trace instrumentation）：TRACE_AddInstrumentFunction\ntrace是一系列顺序执行的指令组成的序列（一条执行路径），通常从程序的入口点开始，只到某个条件触发了分支或程序结束：\n无条件的控制转移：call、ret（trace可以包含jcc指令，因此trace中的代码可能会有多条执行路径，多个基本块） 设定的条件控制转移数 设定的trace的指令数 函数插桩（routine instrumentation）：RTN_AddInstrumentFunction\nroutine表示程序中的函数或子例程，是一组指令的集合，通常包含在一个函数体内。Pin中使用RTN对象表示程序中的函数，可用于分析函数调用、返回等操作。\n映像插桩（Image instrumentation）：IMG_AddInstrumentFunction\nimage指程序在内存中的可执行映像或库文件。Pin中使用IMG对象表示加载到内存中的可执行映像或库文件。\nimage instrumentation需要通过符号信息划定routine边界，因此必须在PIN_Init之前调用PIN_InitSybmols。\nPin插桩多线程程序 Pin提供锁机制（PIN_LOCK）和线程管理（PIN_Yield）API，能够对多线程程序进行插桩。Pin在每个线程开始和结束时提供回调（PIN_AddThreadStartFunction和PIN_AddThreadFiniFunction）。Pin提供一个分析例程参数IARG_THREAD_ID，用于传递线程ID，这个ID由PIN生成的，与O/S系统线程ID不同，是一个从0开始的很小的数字，可用作线程数据数组的索引或Pin用户锁的值。\ncontext概念 我们最开始介绍过了，pin 在插桩前后要能够保存和恢复可执行文件的上下文 (context) 信息，这样才能够保证 pin 不会影响到原目标插桩程序的正常执行，我们可以在调用 INS_InsertCall 函数时，将这个 context 作为一个参数传递给具体插桩函数 (IARG_CONTEXT)，通过这个 context 我们可以读取/修改架构级别(逻辑)寄存器的具体值，包括整型寄存器、浮点 status/control 寄存器，fp 栈寄存器等等，这些函数的具体用法不过多的解释，注意在插桩函数中对这些寄存器的修改返回后都被忽略，如果想真正实现能在修改后的 context 运行，要执行下面的 PIN_ExcuteAt 函数，另外这些寄存器都是架构级别的，无法访问到物理寄存器级别。\nPin官方实例 计算指令数据（指令级插桩）\n目标程序每执行一条指令前会先调用注册的插桩函数Instruction，这个函数会在每次执行指令前调用docount函数，令全局变量icount自增1，然后执行原始指令，重复进行该过程，直到程序执行结束，将统计结果写入指定的输出文件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026#34;pin.H\u0026#34; using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; //声明一个全局变量统计指令条数 static UINT64 icount = 0; //每次Instrction函数都会调用这个函数使icount+1 VOID docount() { icount++; } //每执行一条instruction前都会执行Instruction函数 VOID Instruction(INS ins, VOID* v) { //ins为当前程序准备执行的指令 //IPOINT_BEFORE指定在指令执行前执行函数 //docount为注册的函数 //IARG_END指明传入docount的参数的结尾，这里docount传入参数为空 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); } KNOB\u0026lt; string \u0026gt; KnobOutputFile(KNOB_MODE_WRITEONCE, \u0026#34;pintool\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;inscount.out\u0026#34;, \u0026#34;specify output file name\u0026#34;); // 最后结束时执行这个函数，将指令条数统计结果写入输出文件中 VOID Fini(INT32 code, VOID* v) { OutFile.setf(ios::showbase); OutFile \u0026lt;\u0026lt; \u0026#34;Count \u0026#34; \u0026lt;\u0026lt; icount \u0026lt;\u0026lt; endl; OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u0026lt;\u0026lt; \u0026#34;This tool counts the number of dynamic instructions executed\u0026#34; \u0026lt;\u0026lt; endl; cerr \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; KNOB_BASE::StringKnobSummary() \u0026lt;\u0026lt; endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ /* argc, argv are the entire command line: pin -t \u0026lt;toolname\u0026gt; -- ... */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化 pin if (PIN_Init(argc, argv)) return Usage(); //打开输出文件 OutFile.open(KnobOutputFile.Value().c_str()); // 注册Instruction函数，每次执行指令前调用 INS_AddInstrumentFunction(Instruction, 0); //注册终止函数 PIN_AddFiniFunction(Fini, 0); //开始执行程序 PIN_StartProgram(); return 0; } ","permalink":"https://weak-dog.github.io/en/posts/tech/pin1/","summary":"Intel pin 二进制动态插桩简","title":"Pin1"},{"content":"jTrans：Jump-Aware Transformer for Binary Code Similarity Detection 论文提出了一种新的学习二进制代码representation的方法jTrans：设计了一种新的jump-aware representation以及相应的预训练任务。同时构造了一个新的二进制程序数据集BinaryCorp。\n传统的二进制相似性检测（BCSD）方法大多基于CFG，这种方法时间开销大且鲁棒性差，因为编译器优化等因素会改变程序CFG，改进方法通过计算CFG片段的相似性提高鲁棒性，但基于人工构造的特征，导致这些方法不能精确提取程序语义。\nSOTA方法大多基于机器学习技术，将目标二进制程序转化成特征向量，在向量空间中计算相似性。Asm2Vec和SAFE等基于NLP方法；另一些方法基于GNN学习CFG的representation；还有一些方法结合使用上述两种方法：使用NLP技术计算基本块的representation，根据CFG构造GNN进一步处理基本块representation。\nSOTA方法存在的缺点：\nNPL-based方法只考虑了指令的序列顺序以及指令之间的关系，而忽略了程序的实际执行信息（如控制流），缺乏对程序的语义理解，无法应对编译优化产生的影响。 仅依靠CFG会遗漏每个基本块的语义，Genius和Gemini使用人工提取的特征（指令数）扩展CFG，但这些特征不足以捕获代码语义。另外，这些方案使用GNN理解CFG，GNN只能捕获结构信息，而且训练和并行相对困难。 用于训练和评估现有方案的数据集的体量和多样性不够大，缺乏一个通用的大型数据集。SOTA各自使用各自构建的数据集，存在过拟合的可能，造成性能高的假象。 jump-aware representation即通过共享指令的每个跳转目标的token embedding和position embedding参数来捕获控制流信息。首先使用无监督学习任务对jTrans进行预训练，学习指令语义和控制流信息，之后对jTrans进行微调，匹配语义相似的函数。不依赖于GNN遍历相应的CFG。\nPreprocessing Instructions 使用助记符和操作数作为tokens 使用\u0026lt;str\u0026gt;代表字符串 使用\u0026lt;const\u0026gt;代表立即数 将外部函数调用的名称和标签作为tokens，将内部函数调用的名称替换为\u0026lt;function\u0026gt; 对于每个跳转对，使用JUMP_XXX替换源token，XXX是该跳转对的目标token顺序，消除随机基址的影响。 Modeling Jump Instructions 修改了位置编码机制，以反映跳转指令的影响。位置编码的隐含逻辑是标记之间的距离越大，表示相互影响越弱，而跳转指令能够将代码中相聚较远的区域结合起来。方法是通过参数共享实现：对于每个跳转对，source token\u0026rsquo;s embedding被用作target token的positional encoding。jTrans目前只考虑了直接跳转。\nTrain Pre-train jTrans\nMLM\njump task prediction(JTP)：给定一个随机选择的jump source token，标记为\u0026lt;LOC\u0026gt;，预测相应的target token。\nFine-Tuning\n针对函数相似性检查这一监督学习任务对模型进行微调。\n","permalink":"https://weak-dog.github.io/en/posts/tech/jtrans/","summary":"jTrans：Jum","title":"JTrans"},{"content":"1. 安装hugo mac用户推荐使用HomeBrew工具安装，执行命令brew install hugo进行安装。\n执行hugo version检查是否安装成功，若出现版本信息则安装成功。\n2. 新建站点 终端进入想要存放网站文件夹的地址，执行hugo new site yoursite，就会在当前文件夹内出现网站目录结构。其中的配置文件为toml格式，如果想要yml格式的配置文件可以执行hugo new site yoursite -f yml。\n网站目录如下\n1 2 3 4 5 6 7 8 9 +------------ │ config.toml ├─archetypes │ default.md ├─content # ├─data ├─layouts ├─static └─themes 3. 更换主题 在hugo官网hugo主题官网上寻找好看的主题，点击会跳转到主题对应的github仓库，将主题下载并放在网站目录的themes文件夹下，在配置文件中添加theme: \u0026quot;yourtheme\u0026quot;属性指定主题名称。\n我选择的是PaperMod主题，config.yml参照了Sulv的网站内容编写（复制）。\nConfig.yml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 baseURL: https://weak-dog.github.io languageCode: zh-cn # en-us title: \u0026#34;Weakdog\u0026#39;s Blog\u0026#34; theme: \u0026#34;PaperMod\u0026#34; # 主题名字，和themes文件夹下的一致 enableInlineShortcodes: true #允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启 buildDrafts: false buildFuture: false buildExpired: false #googleAnalytics: UA-123-45 # 谷歌统计 paginate: 15 # 每页显示的文章数 summaryLength: 20 # 文章概览的自字数，默认70 minify: disableXML: true # minifyOutput: true permalinks: #浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: en # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; # contentDir: content/english weight: 1 profileMode: enabled: true title: (〃\u0026#39;▽\u0026#39;〃) subtitle: \u0026#34;👏🏼欢迎光临维克道格的博客\u0026#34; imageUrl: \u0026#34;img/test.jpeg\u0026#34; #图片放在static/img/Q.gif imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life menu: main: - identifier: home name: 🏠主页 url: / weight: 1 - identifier: posts name: 📚文章 url: posts weight: 2 - identifier: archives name: ⏱时间轴 url: archives/ weight: 3 - identifier: tags name: 🔖标签 url: tags weight: 4 - identifier: about name: 🙋🏻‍♂️关于 url: about weight: 5 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. # description: \u0026#34;这是一个纯粹的博客......\u0026#34; author: weakdog # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors defaultTheme: auto # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 comments: true socialIcons: - name: github url: \u0026#34;https://github.com/weak-dog\u0026#34; - name: email url: \u0026#34;mailto:2562258990@qq.com\u0026#34; # editPost: # URL: \u0026#34;https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content\u0026#34; # Text: \u0026#34;Suggest Changes\u0026#34; # edit text # appendFilePath: true # to append file path to Edit link label: #左上角图标 text: \u0026#34;Weakdog\u0026#39;s Blog\u0026#34; icon: \u0026#34;img/test.jpeg\u0026#34; iconHeight: 35 # analytics: #谷歌分析 # google: # SiteVerificationTag: \u0026#34;XYZabc\u0026#34; assets: favicon: \u0026#34;img/test.jpeg\u0026#34; favicon16x16: \u0026#34;img/test.jpeg\u0026#34; favicon32x32: \u0026#34;img/test.jpeg\u0026#34; apple_touch_icon: \u0026#34;test.jpeg\u0026#34; safari_pinned_tab: \u0026#34;test.jpeg\u0026#34; cover: hidden: false # hide everywhere but not in structured data hiddenInList: false # hide on list pages and home hiddenInSingle: false # hide on single page fuseOpts: #搜索配置 isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] twikoo: version: 1.4.11 taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话 highlight: # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true # noClasses: false # style: monokai style: darcula # codeFences：代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。 # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。 # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。 # lineNoStart：行号从编号几开始，一般从 1 开始。 # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true. # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true. # noClasses：使用 class 标签，而不是内嵌的内联样式 privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true 编辑archetypes文件夹下的default.md来修改文章模板，没有的话就创建一个。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; #标题 date: {{ .Date }} #创建时间 lastmod: {{ .Date }} #更新时间 author: [\u0026#34;weakdog\u0026#34;] #作者 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 description: \u0026#34;\u0026#34; #描述 weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; draft: false # 是否为草稿 comments: true #是否展示评论 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 disableShare: true # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 cover: image: \u0026#34;\u0026#34; #图片路径：posts/tech/文章1/picture.png caption: \u0026#34;\u0026#34; #图片底部描述 alt: \u0026#34;\u0026#34; relative: false --- 4. 目录设置 按照需求在content文件夹下新建一些目录文件夹，用来存储不同类别的文章。在每个文件夹内添加一个_index.md文件，用来设置目录的标题和展示样式。\n例如posts下的_index.md：\n1 2 3 4 --- title: \u0026#34;📚文章\u0026#34; hidemeta: true # --- posts/tech下的_index.md：\n1 2 3 4 --- title: \u0026#34;👨🏻‍💻技术\u0026#34; hidemeta: true --- 5. 启动网站 终端进入网站目录，执行hugo server -D就可以在本地启动网站，预览地址为localhost:1313。\n执行hugo生成文件夹public，里面包含生成的静态网页文件，这个文件夹可以部署到云服务器或者托管到github上。\n推荐使用hugo -F --cleanDestinationDir命令生成静态网页，因为hugo命令只会往public文件夹里添加新内容，而不会删除冗余内容，而-F命令则会覆盖原来的public文件夹而生成一个全新的public。\n6. 写文章 所有的文章被放在content目录下。如果没有定义别的分类目录的话执行hugo new article.md即可在content目录下生成article.md文件。如果自定义了分类目录，比如我想要在content/posts/tech文件夹里新建文章，则执行hugo new posts/tech/article.md命令，这样文章就会生成到指定目录。\n如果需要在文章里插入图片，则需要在文章所属的文件夹内创建一个与文章同名的文件夹，将需要插入的picture.png图片放进去，在md文件里使用![](picture.png)命令调用。\n7. 将网站部署在github page上 在github上创建yourname.github.io公共仓库，将public文件夹里的内容push上去。在settings里按照如图配置即可。\n输入yourname.github.io即可访问网站。\n8. 一些关键命令 本地预览博客：hugo server -D\n写文章：hugo new posts/tech/文章名称.md\n图片路径：![](pic.png)\n发布博客：hugo -F --cleanDestinationDir\n","permalink":"https://weak-dog.github.io/en/posts/tech/%E5%BB%BA%E7%AB%99/","summary":"1. 安装hugo mac","title":"hugo建站"},{"content":"关于我\n英文名: ??? 职业: ??? 运动: ??? ","permalink":"https://weak-dog.github.io/en/about/","summary":"关于我 英文名: ??? 职业","title":"🙋🏻‍♂️关于"}]